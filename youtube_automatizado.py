# -*- coding: utf-8 -*-
"""Youtube automatizado

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OKaIRVA8gXUmZijwqk5uIOwHzGxtc0Jx
"""

!pip install google-api-python-client

!pip install scipy

from googleapiclient.discovery import build
import time
import csv

# Configuración de la API
api_key = "AIzaSyATauf0DY63kXO9CwcfAmuSAOnwMESPc0Y"
youtube = build('youtube', 'v3', developerKey=api_key)

# Video ID del que deseas recopilar los datos
video_id = "V--rzwmUglo"

# Inicializar el archivo CSV
fieldnames = ['Time', 'viewCount', 'likeCount', 'favoriteCount', 'commentCount', 'Number of like']
with open('video_data.csv', 'w', newline='') as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()

# Función para recopilar los datos
def obtener_datos_video(video_id):
    request = youtube.videos().list(
        part="statistics",
        id=video_id
    )
    response = request.execute()

    if response['items']:
        stats = response['items'][0].get('statistics', {})
        viewCount = stats.get('viewCount', 0)
        likeCount = stats.get('likeCount', 0)
        favoriteCount = stats.get('favoriteCount', 0)
        commentCount = stats.get('commentCount', 0)

        # Obtener el número de "Me gusta"
        request = youtube.videos().list(
            part="statistics",
            id=video_id,
            fields="items(statistics(likeCount))"
        )
        response = request.execute()
        if response['items']:
            likeCount = response['items'][0]['statistics']['likeCount']

        return viewCount, likeCount, favoriteCount, commentCount, likeCount
    else:
        return 0, 0, 0, 0, 0

# Recopilar datos cada 10 minutos durante 2 horas
for i in range(24):
    current_time = time.strftime("%H:%M:%S", time.localtime())
    viewCount, likeCount, favoriteCount, commentCount, number_of_like = obtener_datos_video(video_id)
    with open('video_data.csv', 'a', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writerow({'Time': current_time, 'viewCount': viewCount, 'likeCount': likeCount, 'favoriteCount': favoriteCount, 'commentCount': commentCount, 'Number of like': number_of_like})
    print(f"Datos recopilados a las {current_time}")
    time.sleep(600) # Esperar 10 minutos (600 segundos)

print("Recopilación de datos finalizada.")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#imprtar el archivo .csv
archivo_CSV = '/content/video_data.csv'
df = pd.read_csv(archivo_CSV)
df

from matplotlib import pyplot as plt
df['Number of like'].plot(kind='line', figsize=(8, 4), title='Number of like')
plt.gca().spines[['top', 'right']].set_visible(False)

from matplotlib import pyplot as plt
df['commentCount'].plot(kind='line', figsize=(8, 4), title='commentCount')
plt.gca().spines[['top', 'right']].set_visible(False)

from matplotlib import pyplot as plt
df['likeCount'].plot(kind='line', figsize=(8, 4), title='likeCount')
plt.gca().spines[['top', 'right']].set_visible(False)

from matplotlib import pyplot as plt
df['viewCount'].plot(kind='line', figsize=(8, 4), title='viewCount')
plt.gca().spines[['top', 'right']].set_visible(False)

#Descripcion estadistica del dataframe
descripcion_estadistica = df.describe()
descripcion_estadistica

from scipy.interpolate import interp1d
import numpy as np

# Leer el archivo CSV
data = pd.read_csv('video_data.csv')

# Convertir la columna 'Time' a formato de horas
data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.minute/60 + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.second/3600

# Crear una función de interpolación
interp_func = interp1d(data['Time'], data['viewCount'], kind='cubic')

# Función para calcular la derivada
def calc_derivative(t):
    derivative = np.gradient(interp_func(data['Time']), data['Time'])
    return derivative[np.searchsorted(data['Time'], t)]

# Crear una lista para almacenar las derivadas
derivatives = []

# Calcular las derivadas para cada tiempo y almacenarlas en la lista
for time_value in data['Time']:
    derivative_value = calc_derivative(time_value)
    derivatives.append(derivative_value)

# Ejemplo de uso
time_value = 2  # Tiempo en horas
derivative_value = calc_derivative(time_value)
print(f"La derivada en t={time_value} horas es: {derivative_value:.2f} vistas/hora")

# Estadísticas de la derivada
print(f"Media de la derivada: {np.mean(derivatives):.2f} vistas/hora")
print(f"Desviación estándar de la derivada: {np.std(derivatives):.2f} vistas/hora")
print(f"Valor mínimo de la derivada: {np.min(derivatives):.2f} vistas/hora")
print(f"Valor máximo de la derivada: {np.max(derivatives):.2f} vistas/hora")

# Graficar la derivada
plt.figure(figsize=(10, 6))
plt.plot(data['Time'], derivatives)
plt.xlabel('Tiempo (horas)')
plt.ylabel('Derivada (vistas/hora)')
plt.title('Derivada del número de vistas')
plt.grid(True)
plt.show()

from scipy.interpolate import interp1d

# Leer el archivo CSV
data = pd.read_csv('video_data.csv')

# Convertir la columna 'Time' a formato de horas
data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.minute/60 + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.second/3600

# Crear una función de interpolación
interp_func = interp1d(data['Time'], data['likeCount'], kind='cubic')

# Función para calcular la derivada
def calc_derivative(t):
    derivative = np.gradient(interp_func(data['Time']), data['Time'])
    return derivative[np.searchsorted(data['Time'], t)]

# Ejemplo de uso
time_value = 2  # Tiempo en horas
derivative_value = calc_derivative(time_value)
print(f"La derivada en t={time_value} horas es: {derivative_value:.2f} likes/hora")

# Leer el archivo CSV
data = pd.read_csv('video_data.csv')

# Convertir la columna 'Time' a formato de horas
data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.minute/60 + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.second/3600

# Crear una función de interpolación
interp_func = interp1d(data['Time'], data['likeCount'], kind='cubic')

# Calcular la derivada en todos los puntos de tiempo
derivatives = np.gradient(interp_func(data['Time']), data['Time'])

# Estadísticas de la derivada
print(f"Media de la derivada: {np.mean(derivatives):.2f} likes/hora")
print(f"Desviación estándar de la derivada: {np.std(derivatives):.2f} likes/hora")
print(f"Valor mínimo de la derivada: {np.min(derivatives):.2f} likes/hora")
print(f"Valor máximo de la derivada: {np.max(derivatives):.2f} likes/hora")

# Graficar la derivada
plt.figure(figsize=(10, 6))
plt.plot(data['likeCount'], derivatives)
plt.xlabel('Tiempo (horas)')
plt.ylabel('Derivada (likes/hora)')
plt.title('Derivada del número de likes')
plt.grid(True)
plt.show()

from scipy.interpolate import interp1d

# Leer el archivo CSV
data = pd.read_csv('video_data.csv')

# Convertir la columna 'Time' a formato de horas
data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.minute/60 + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.second/3600

# Crear una función de interpolación
interp_func = interp1d(data['Time'], data['commentCount'], kind='cubic')

# Función para calcular la derivada
def calc_derivative(t):
    derivative = np.gradient(interp_func(data['Time']), data['Time'])
    return derivative[np.searchsorted(data['Time'], t)]

# Ejemplo de uso
time_value = 2  # Tiempo en horas
derivative_value = calc_derivative(time_value)
print(f"La derivada en t={time_value} horas es: {derivative_value:.2f} comentarios/hora")

# Leer el archivo CSV
data = pd.read_csv('video_data.csv')

# Convertir la columna 'Time' a formato de horas
data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.minute/60 + pd.to_datetime(data['Time'], format='%H:%M:%S').dt.second/3600

# Crear una función de interpolación
interp_func = interp1d(data['Time'], data['commentCount'], kind='cubic')

# Calcular la derivada en todos los puntos de tiempo
derivatives = np.gradient(interp_func(data['Time']), data['Time'])

# Estadísticas de la derivada
print(f"Media de la derivada: {np.mean(derivatives):.2f} comentarios/hora")
print(f"Desviación estándar de la derivada: {np.std(derivatives):.2f} comentarios/hora")
print(f"Valor mínimo de la derivada: {np.min(derivatives):.2f} comentarios/hora")
print(f"Valor máximo de la derivada: {np.max(derivatives):.2f} comentarios/hora")

# Graficar la derivada
plt.figure(figsize=(10, 6))
plt.plot(data['commentCount'], derivatives)
plt.xlabel('Tiempo (horas)')
plt.ylabel('Derivada (comentarios/hora)')
plt.title('Derivada del número de comentarios')
plt.grid(True)
plt.show()